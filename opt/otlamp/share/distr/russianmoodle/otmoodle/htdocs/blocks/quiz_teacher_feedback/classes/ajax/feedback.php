<?php

// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Блок комментарий преподавателя. Класс блока.
 *
 * @package    block
 * @subpackage block_quiz_teacher_feedback
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */


namespace block_quiz_teacher_feedback\ajax;

defined('MOODLE_INTERNAL') || die();

// Подключение дополнительных библиотек
require_once($CFG->libdir . "/externallib.php");
require_once($CFG->dirroot . '/blocks/quiz_teacher_feedback/locallib.php');
require_once($CFG->dirroot . '/mod/quiz/locallib.php');
require_once($CFG->libdir.'/blocklib.php');

use external_api;
use external_function_parameters;
use external_value;
use question_engine;


class feedback extends external_api
{
    
    /**
     * Returns description of method parameters
     * @return external_function_parameters
     */
    public static function get_data_parameters()
    {
        // ID набора вопросов
        $qubaid = new external_value(
            PARAM_INT,
            'qubaid',
            VALUE_REQUIRED
        );
        // Номер слота в наборе
        $slot = new external_value(
            PARAM_INT,
            'slot',
            VALUE_REQUIRED,
            false
        );
        // Токен доступа
        $token = new external_value(
            PARAM_RAW_TRIMMED,
            'Token, generated by rule: md5(sesskey().$qaid.$qubaid.$slot)',
            VALUE_REQUIRED,
            false
        );
        // ID - блока
        $instance = new external_value(
            PARAM_INT,
            'Block instance id',
            VALUE_REQUIRED,
            false
        );
        
        $params = [
            'qubaid' => $qubaid,
            'slot' => $slot,
            'token' => $token,
            'instance' => $instance
        ];
        
        return new external_function_parameters($params);
    }
    
    /**
     * Получение информации о текущем этапе прохождения тестирования
     * 
     * @param int $qubaid - ID набора вопросов
     * @param int $slot - Номер слота в наборе
     * @param string $token - Токен доступа
     * @param int $instance - ID - блока
     * @return string
     */
    public static function get_data($qubaid, $slot, $token, $instance)
    {
        $data = [];
        // Получим конфиг блока
        $block = block_quiz_teacher_feedback_get_block($instance);
        // Получение набора вопросов
        $quba = question_engine::load_questions_usage_by_activity($qubaid);
        if ( empty($quba) && empty($block) )
        {
            $data['error'] = get_string('eror_ajax_invalid_param', 'block_quiz_teacher_feedback');
        }
        
        // Получение попытки прохождения вопроса пользователем
        $qa = $quba->get_question_attempt($slot);
        if ( empty($qa) )
        {
            $data['error'] = get_string('eror_ajax_invalid_param', 'block_quiz_teacher_feedback');
        } elseif ( $block->is_slot_should_be_graded($qa)  )
        {
            // Получение ID попытки прохождения вопроса
            $qaid = (int)$qa->get_database_id();
            // Сравнение подписей запроса
            $currenttoken = md5(sesskey().$qaid.$qubaid.$slot);
            if ( $token !== $currenttoken )
            {// Подписи не совпадают
                $data['error'] = get_string('eror_ajax_invalid_token', 'block_quiz_teacher_feedback');
            } else
            {
                // Получение комментария по вопросу
                $feedback = block_quiz_teacher_feedback_get_feedback($qaid);
                $data['feedback'] = '';
                $data['grade'] = '';
                $data['completedstring'] = get_string('feedback_info_current_notcompleted', 'block_quiz_teacher_feedback');
                $data['checkboxstatus'] = $block->get_request_status($qa);
                if ( ! empty($feedback->feedback) )
                {// Добавление комментария по вопросу
                    $data['feedback'] = $feedback->feedback;
                }
                if ( isset($feedback->grade) && $feedback->grade !== null )
                {// Добавление оценки по вопросу
                    $data['grade'] = format_float($feedback->grade, 2, true, true);
                }
                if ( ! empty($feedback->completed) )
                {// Добавление строки о завершении вопроса
                    $data['completedstring'] = get_string('feedback_info_current_completed', 'block_quiz_teacher_feedback');
                }
                // Проверим, что все элементы под контролем оценены
                $questions = $quba->get_slots();
                if ( ! empty($questions) )
                {
                    // Проверим статус, что преподаватель подтвердил все вопросы студента
                    $questions_config = $block->get_formated_config_questions();
                    $completeall = 'complete';
                    if ( empty($questions_config) )
                    {
                        $completeall = 'incomplete';
                    }
                    else
                    {
                        foreach ($questions as $question)
                        {
                            $qa = $quba->get_question_attempt($question);
                            $slot = $qa->get_slot();
                            $feedback = block_quiz_teacher_feedback_get_feedback($qa->get_database_id());
                            if ( isset($questions_config[$slot])
                                && ! empty($questions_config[$slot])
                                && empty($feedback->completed)
                                && ! empty($qa->get_question()->length))
                            {
                                $completeall = 'incomplete';
                                break;
                            }
                        }
                        $data['completeall'] = $completeall;
                    }
                }
            }
        }
        return json_encode($data);
    }
    
    /**
     * @return \external_value
     */
    public static function get_data_returns()
    {
        return new external_value(PARAM_RAW, 'JSON-encoded feedback-data');
    }
}